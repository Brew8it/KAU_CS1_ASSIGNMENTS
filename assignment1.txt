1 What is the adversary’s goal and capabilities in IND-CPA?
	*The goal is to prove that an symmetric encryption algorithm is unsecure via a game.
	if an symmetric encryption algorithm is 50/50 the algorithm is deamd to be secure since
	the adversary is only guessing at that point.
	*The capabillities the adversary has is an "encryption oracle" meaning that it can
	send how many messages it wants and get back the cyphertext and compute it as much it
	wants.
2 What is the difference between an IV and a nonce?
	*Nonce a number only used once.
	*IV(initialization vector): has to be an random stream of bytes as the same size as 
	the CBC block size. This vector also has to be unpredictable.
		Conversely, most block cipher modes of operation require an IV which is random 			and unpredictable, or at least unique for each message encrypted with a given 			key. (Of course, if each key is only ever used to encrypt a single message, 			one can get away with using a fixed IV.) This random IV ensures that each 			message encrypts differently, such that seeing multiple messages encrypted 			with the same key doesn't give the attacker any more information than just 			seeing a single long message. In particular, it ensures that encrypting the 			same message twice yields two completely different ciphertexts, which is 			necessary in order for the encryption scheme to be semantically secure.
	The difference is that a Nonce is a random number only used once and for a short time
	with the intention of beeing replaced by or converted into something better(e.g CTR)
	An IV is also used as input for an crypto primitive to achieve randomization to our 		first block in a CBC mode and therefor messages that is the same (m1=m2) will not
	encrypt to the same cipher.
	
3 What is the difference between a protocol and an algorithm?
	*algorithm: Is how we process some data to derive at an awnser.
	*protocol: Its like an algorithm but it invoves several players / entities
	that is communicating using primitives and / or schemes
		A protocol is a set of rules that governs how a system operates. The rules 			establish the basic functioning of the different parts, how they interact with 			each other, and what conditions are necessary for a healthy implementation. 			The different parts of a protocol are not sensitive to order or chronology – 			it doesn’t matter which part is enacted first. And a protocol doesn’t tell the 			system how to produce a result. It doesn’t have an objective other than a 			smooth execution. It doesn’t produce an output.

		It’s like the engine of a car, how a car works.

		An algorithm, on the other hand, is a set of instructions that produces an 			output or a result. It can be a simple script, or a complicated program. The 			order of the instructions is important, and the algorithm specifies what that 			order is. It tells the system what to do in order to achieve the desired 			result. It may not know what the result is beforehand, but it knows that it 			wants one.

		It’s what you need to do to drive the car, the actions that the driver 			performs.

		The protocol is a set of rules that determines how the system functions.

		The algorithm tells the system what to do.

		The protocol is. The algorithm does.
	
4 Describe the CBC and CTR block-cipher modes.
	*In CBC mode each block of plaintext is XOR'd with the previous ciphertext block 
	(if first block the IV is used) before beeing encrypted. To make sure that every
	message is unique an IV must be used on the first block. Since the block cipher
	encryption relys on the the previous block used the encryption process must be done in 		sequence and cannot be parallelized(downside/slow).
	One other important aspect is padding, when we try to break down a message into blocks
	what will happen if the last block is not even with the block size?
	message_block != block_size. We have to padd the last block so the block is fully 		filled. When padding we ussaly fill with ones or zeros. But when we decrypt how
	much do we need to unpad? One way in python is useing these lambda expressions:
	BLOCK_SIZE = 16  # Bytes
	pad = lambda s: s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * \
                chr(BLOCK_SIZE - len(s) % BLOCK_SIZE)
	unpad = lambda s: s[:-ord(s[len(s) - 1:])]
	
	Decryption is almsot done in the same way but insted of XORing in the beginning.
	We XOR after we have decrypted the cipher text. We XOR with the previous ciphertext
	meaning that we can parallelize the decryption process and gain alot of speed.
	
	https://upload.wikimedia.org/wikipedia/commons/8/80/CBC_encryption.svg
	https://upload.wikimedia.org/wikipedia/commons/2/2a/CBC_decryption.svg


	*CTR mode(counter mode): Is a mode of operation that works by concatenating 
	a nonce with a block counter. The counter is incremented with each of the blocks and
	then padded with zeroes so that the whole string is as long as the block size. This
	resulting string is then run trough the block cioher. The output of the block zipher 		is the used XOR'd with the message block to produce the final encrypted block.
	To decrypt we just do the same thing on the reciver side except when we XOR, we 
	xOR with the ciphertext block. This is since XORing a bit with the same value twice
	will produce the original bit. pi ⊕ si ⊕ si = pi. What this means is that both
	encryption and decryption does the same thing. in both the cases you produce the
	encrypted block from the concatenated string and then you either XOR the plaintext
	or ciphertext block. This also means that this can be done in parallel.	
	
	https://upload.wikimedia.org/wikipedia/commons/4/4d/CTR_encryption_2.svg
	https://upload.wikimedia.org/wikipedia/commons/3/3c/CTR_decryption_2.svg
	
	PS: With hardware supprt CBC mode can be as fast if not faster then CTR mode. But
	this needs to be implemented in the hardware that most CPU manufactures today 		implements


5 For symmetric encryption with a block cipher using CBC-mode, what is the consequence of:
	1 Using a predictable IV?
	2 Reusing an IV?
6 How is ROT13 related to the Caesar cipher? Give an example.
7 Assume that you compress a message m as part of encrypting it with a
semantically secure encryption algorithm: does this break semantic security? Explain why (not).
8 Attempt to answer the question on slide 13.
